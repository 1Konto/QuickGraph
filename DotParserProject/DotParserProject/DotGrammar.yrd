{
open System.Collections.Generic
open DotParserProject.CollectDataFuncs

let adj_list = new Dictionary<string, Dictionary<string, int>>()
let graph_info = new Dictionary<string, string>()

//constants
let type_key = "type"
let strict_key = "is_strict"
let name_key = "name"
}

tokens {
    _ of string
}

options {
    translate = true
    module = "DotParserProject.DotParser"
    infEpsPath = epsilons
    pos = uint64
}

module DotGrammar

list <item separator>: {[]} | hd=item tl=(separator i=item {i})* {hd::tl}

[<Start>]
graph : s=[STRICT] g=(t=GRAPH {t} | t=DIGRAPH {t}) name=[id] LCURBRACE x=stmt_list RCURBRACE SEP 
{CollectDataFuncs.AddInfo graph_info [strict_key, (Utils.OptToStr s); type_key, g; name_key, (Utils.OptToStr name)]}

stmt_list : lst=(l=full_stmt SEP {l})* {}

full_stmt : 
       node_stmt 
     | l = edge_stmt {l}
	 | attr_stmt 
	 | k=id ASSIGN v=id {} 
	 | subgraph 

attr_stmt : (GRAPH {1} | NODE | EDGE) lst=attr_list {}

attr_list : l=(LSQBRACE l=a_list RSQBRACE {})* {}

a_list : lst=list<(k=id ASSIGN v=id {}) COMMA> {}

edge_stmt : edges=list<(nodeID=node_id {nodeID} | subgraph) edge_operator> attr_list {CollectDataFuncs.AddEdges adj_list edges}

edge_operator : op=(p=EDGEOP {p} | p=DIEDGEOP {p}) {CollectDataFuncs.AddInfo graph_info [op, ""]}

node_stmt : nodeID=node_id l=attr_list {nodeID}

node_id : nodeID=id [ port ] {nodeID}

port : (COL id [ COL compass_pt {1}] {1} | COL compass_pt {1}) {1}

subgraph : [ SUBGR [ id ] {1}] LCURBRACE l=stmt_list RCURBRACE {}

compass_pt : i=ID {}

id : i=ID {i}