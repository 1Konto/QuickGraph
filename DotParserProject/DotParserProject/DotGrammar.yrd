{
open System.Collections.Generic
open ParsingFuncs
let adj_list = new Dictionary<string, HashSet<string>>()
}

tokens {
    _ of string
}

options {
    translate = true
    module = "DotParserProject.DotParser"
    infEpsPath = epsilons
    pos = uint64
}

module DotGrammar

list <item separator>: {[]} | hd=item tl=(separator i=item {string i})* {(string hd)::tl}

[<Start>]
graph : [ STRICT {1} ] ( GRAPH {1} | DIGRAPH {1}) [ id ] LCURBRACE x=stmt_list RCURBRACE SEP {}

stmt_list : lst=(l=full_stmt SEP {l})* {}

full_stmt : 
       node_stmt 
     | l = edge_stmt {l}
	 | attr_stmt 
	 | k=id ASSIGN v=id {} 
	 | subgraph 

attr_stmt : (GRAPH {1} | NODE | EDGE) lst=attr_list {}

attr_list : l=(LSQBRACE l=a_list RSQBRACE {})* {}

a_list : lst=list<(k=id ASSIGN v=id {}) COMMA> {}

edge_stmt : edges=list<(nodeID=node_id | subgraph) edge_operator> attr_list {ParsingFuncs.AddEdges adj_list edges}

edge_operator : EDGEOP {1} | DIEDGEOP {1}

node_stmt : nodeID=node_id l=attr_list {nodeID}

node_id : nodeID=id [ port ] {nodeID}

port : (COL id [ COL compass_pt {1}] {1} | COL compass_pt {1}) {1}

subgraph : [ SUBGR [ id ] {1}] LCURBRACE l=stmt_list RCURBRACE {}

compass_pt : i=ID {}

id : i=ID  {i}